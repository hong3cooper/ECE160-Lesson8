<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>ECE160 - Lesson 7 - Structures, Github Forks</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>ECE160 - Lesson 7</h1>
					<h3>Structures, Github Forks</h3>
					<p>
						<small>Professor Hong</small>
					</p>
					
				</section>
						
				<section>
					<section data-markdown>
						<textarea data-template>
						## Review & Questions
						</textarea>
					</section>
				</section>
				
				<section>
					<section data-markdown>
						<textarea data-template>
						## Quiz #3
						* Closed Book
						* No Laptops
						* 30 minutes
						</textarea>
					</section>
				</section>
				
				<section>
					<section data-markdown>
						<textarea data-template>
						## Wrap-up Arrays of Structures from Lesson #6
						</textarea>
					</section>
				</section>
				
				<section>
					<section data-markdown>
						<script type="text/template">
							## Pointers to Structures
						</script>
					</section>
					
					<section data-markdown>
						<script type="text/template">
							## Keyword-Counting Program w/ Pointers
							```
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100

struct key {
    char *word;
    int count;
} keytab[] = {
        "auto", 0,
        "break", 0,
        "case", 0,
        "char", 0,
        "const", 0,
        "continue", 0,
        "default", 0,
        /* ... */
        "unsigned", 0,
        "void", 0,
        "volatile", 0,
        "while", 0
};

#define NKEYS (sizeof keytab / sizeof keytab[0])

int getword(char *, int);
struct key *binsearch(char *, struct key *, int);
int getch(void);
void ungetch(int);


// K&R Pg. 137
// count C keywords; pointer version

int main()
{
    char word[MAXWORD];
    struct key *p;

    while (getword(word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            if ((p=binsearch(word, keytab, NKEYS)) != NULL)
                p->count++;

    for (p = keytab; p < keytab + NKEYS; p++)
        if (p->count > 0)
            printf("%4d %s\n",
                p->count, p->word);

    return 0;
}

// binserach: find word in tab[0]...tab[n-1]
struct key *binsearch(char *word, struct key *tab, int n)
{
    int cond;
    struct key *low = &tab[0];
    struct key *high = &tab[n];
    struct key *mid;

    while (low < high) {
        mid = low + (high-low) / 2;
        if ((cond = strcmp(word, mid->word)) < 0)
            high = mid;
        else if (cond > 0)
            low = mid + 1;
        else
            return mid;
    }

    return NULL;

}

// getword:get next word or character from input

int getword(char *word, int lim)
{
    int c, getch(void);
    void ungetch(int);
    char *w = word;

    while (isspace(c = getch()))
        ;

    if (c != EOF)
        *w++ = c;
    if (!isalpha(c)) {
        *w = '\0';
        return c;
    }

    for ( ; --lim > 0; w++)
        if (!isalnum(*w = getch())) {
            ungetch(*w);
            break;
        }

    *w = '\0';

    return word[0];
}

// K&R pg. 79
#define BUFSIZE 100

char buf[BUFSIZE]; // buffer for ungetch
int bufp = 0; // next free position in buf

int getch(void) // get a (possibly pushed back) character
{
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) // push character back on input
{
    if (bufp >= BUFSIZE)
        printf("ungetch: too many caracters\n");
    else
        buf[bufp++] = c;
}
							```
							* <code>./a.exe < keywordCount.c</code>
						</script>
					</section>
			
					<section data-markdown>
						<script type="text/template">
							## Notes
							* The return type of binsearch is a pointer to the key structure.
							* The addition of 2 pointers is illegal, but subtraction is legal.
							* Note that we also avoid illegal pointers.
						</script>
					</section>
					
				</section>
				
				<section>
					<section data-markdown>
						<script type="text/template">
							## Self-referential Structures
						</script>
					</section>
					
					<section data-markdown>
						<script type="text/template">
							## Tree Example
							```
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// K&R pg. 140-143
#define MAXWORD 100

struct tnode {           // the tree node:
    char *word;          // points to the text
    int count;           // number of occurrences
    struct tnode *left;  // left child
    struct tnode *right; // right child
};

struct tnode *addtree(struct tnode *, char *);
void treeprint(struct tnode *);
int getword(char *, int);

// word frequency count
int main()
{
    struct tnode *root;
    char word[MAXWORD];

    root = NULL;
    while (getword(word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            root = addtree(root, word);
    treeprint(root);
    return 0;
}

struct tnode *talloc(void);
char *mystrdup(char *);

// addtree: add a node with w, at or below p
struct tnode *addtree(struct tnode *p, char *w)
{
    int cond;

    if (p == NULL) {    // a new word has arrived
        p = talloc();   // make a new node
        p->word = mystrdup(w);
        p->count = 1;
        p->left = p->right = NULL;
    } else if ((cond = strcmp(w, p->word)) == 0)
        p->count++;     // repeated word
    else if (cond < 0)  // less than into left subtree
        p->left = addtree(p->left, w);
    else                // greater than into right subtree
        p->right = addtree(p->right, w);
    return p;
}

// treeprint: in-order print of tree p
void treeprint(struct tnode *p)
{
    if (p != NULL) {
        treeprint(p->left);
        printf("%4d %s\n", p->count, p->word);
        treeprint(p->right);
    }
}

// talloc: make a tnode
struct tnode *talloc(void)
{
    return (struct tnode *) malloc(sizeof(struct tnode));
}

char *mystrdup(char *s) // make a duplicate of s
{
    char *p;
    p = (char *) malloc(strlen(s)+1); // +1 for '\0'
    if (p != NULL)
        strcpy(p, s);
    return p;
}


int getword(char *word, int lim)
{
    int c, getch(void);
    void ungetch(int);
    char *w = word;

    while (isspace(c = getch()))
        ;

    if (c != EOF)
        *w++ = c;
    if (!isalpha(c)) {
        *w = '\0';
        return c;
    }

    for ( ; --lim > 0; w++)
        if (!isalnum(*w = getch())) {
            ungetch(*w);
            break;
        }

    *w = '\0';

    return word[0];
}


// K&R pg. 79
#define BUFSIZE 100

char buf[BUFSIZE]; // buffer for ungetch
int bufp = 0; // next free position in buf

int getch(void) // get a (possibly pushed back) character
{
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) // push character back on input
{
    if (bufp >= BUFSIZE)
        printf("ungetch: too many caracters\n");
    else
        buf[bufp++] = c;
}
							```
						</script>
					</section>
			
					
				</section>
				
				<section>
					<section data-markdown>
						<script type="text/template">
							## Table Lookup
						</script>
					</section>
					
					<section data-markdown>
						<script type="text/template">
							## Hash Table
							```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// K&R Pg. 144-145

struct nlist {              // table entry:
    struct nlist *next;     // next entry in chain
    char *name;             // defined name
    char *defn;             // replacement text
};

#define HASHSIZE 101
static struct nlist *hashtab[HASHSIZE]; // pointer table

// hash: form hash value for string
unsigned hash(char *s)
{
    unsigned hashval;

    for (hashval = 0; *s != '\0'; s++)
        hashval = *s + 31 * hashval;
    return hashval % HASHSIZE;
}

// lookup:look for s in hashtab
struct nlist *lookup(char *s)
{
    struct nlist *np;

    // loop through linked list
    for (np = hashtab[hash(s)]; np != NULL; np = np->next)
        if (strcmp(s, np->name) == 0)
            return np; // found

    return NULL;       // not found
}

struct nlist *lookup(char *);

// install:put (name, defn) in hashtab
struct nlist *install(char *name, char *defn)
{
    struct nlist *np;
    unsigned hashval;

    if ((np = lookup(name)) == NULL) { // not found
        np = (struct nlist *) malloc(sizeof(*np));
        if (np == NULL || (np->name = strdup(name)) == NULL)
            return NULL;
        hashval = hash(name);
        np->next = hashtab[hashval];
        hashtab[hashval] = np;
    } else // already there
        free((void *) np->defn); // free previous defn
    if ((np->defn = strdup(defn)) == NULL)
        return NULL;

    return np;
}


int main()
{
    // Example of using a hash table
    install("A", "65");
    install("B", "66");

    struct nlist *n = lookup("B");

    printf("%s", n->defn);

    return 0;
}
							```
						</script>
					</section>
			
					
				</section>
				
				<section>
					<section data-markdown>
						<script type="text/template">
							## Typedef
						</script>
					</section>
					
					<section data-markdown>
						<script type="text/template">
							## Basic Typedef
							```
typedef int Length;

Length len, maxlen;
Length *lengths[];

typedef char *String;
String p, ineptr[MAXLINES], alloc(int);
int strcmp(String, String);
p = (String) malloc(100);
							```
						</script>
					</section>
					
					<section data-markdown>
						<script type="text/template">
							## Struct Typedef
							```
typedef struct tnode *Treeptr;

typedef struct tnode{   // the tree node:
    char *word;             // points to the text
    int count;              // number of occurrences
    Treeptr left;           // left child
    Treeptr right;          // right child
} Treenode;

Treeptr talloc(void)
{
    return (Treeptr) malloc(sizeof(Treenode));
}
							```
						</script>
					</section>
			
					
				</section>
				
				<section>
					<section data-markdown>
						<script type="text/template">
							## Unions
						</script>
					</section>
					
					<section data-markdown>
						<script type="text/template">
							## Basic Union Example
							```
union u_tag{
    int ival;
    float fval;
    char *sval;
} u; // will be large enough to hold largest of these types

if (utype == INT)
    printf("%d\n", u.ival);

else if (utype == FLOAT)
    prinf("%f\n", u.fval);

else if (utype == STRING)
    printf("%s\n", u.sval);

else
    printf("bad type %d in utype\n", utype);
							```
						</script>
					</section>
			
					<section data-markdown>
						<script type="text/template">
							## Struct With Union Example
							```
struct {
    char *name;
    int flags;
    int utype;
    union {
        int ival;
        float fval;
        char *sval;
    } u;
} symtab[NSYM];

// the following are equilvalent
*symtab[i].u.sval
symtab[i].u.sval[0]
							```
						</script>
					</section>
					
				</section>
				
				<section>
					<section data-markdown>
						<script type="text/template">
							## Github Forks
						</script>
					</section>
					
					<section data-markdown>
						<script type="text/template">
							## Fork Example
							<a href="https://github.com/Spring2018-ECE160/forkme">
							https://github.com/Spring2018-ECE160/forkme
							</a>
						</script>
					</section>
					
				</section>
				
				<section data-markdown>
					<script type="text/template">
						## Homework
						<a href="https://classroom.github.com/g/90csGNMN">
						https://classroom.github.com/g/90csGNMN
						</a>
					</script>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
